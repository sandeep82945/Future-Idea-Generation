Correlation power analysis (CPA) is a classical method in side-channel attacks. Based on the power consumption model, the correlation between the power consumption of cryptographic devices and the assumed intermediate value is analyzed to recover the key. Theoretically, only a few power traces are required to recover the key when the noise hypothesis is known. However, in the high-frequency and high-noise environment, the completion of CPA requires more power traces, and the computational complexity also increases. Therefore, this paper proposes a fault probability correlation analysis method based on secondary filtering (2F-FPCA), which selects the fault probability traces according to the Hamming Weight of the intermediate value and reduces the number of sampling points by selecting points of interest. This method does not need to access ciphertext and is little affected by noise. Moreover, it can recover the key with fewer fault probability traces and lower computational complexity, improving the attack efficiency of CPA. In this paper, 2F-FPCAs are carried out based on the AES128 algorithm of the Micro Controller Unit (MCU). The key can be recovered successfully using 10 fault probability traces, and the computational complexity is reduced by 10 times. INDEX TERMS Correlation power analysis, side-channel attacks, fault injection attacks, AES ii. preliminaries and practical implementation  a. correlation power analysis CPA mainly uses the correlation between the actual power consumption and the power consumption model. CPA has a general attack strategy, which is divided into 5 steps [17]: •Step 1: Select an intermediate value of the executed algorithm. First, select the power consumption model and establish the leakage function. The intermediate value must be a function that depends on the small part of the key and known nonconstant data value, which is usually the plaintext or the ciphertext. The most widely used power consumption model is the Hamming Distance (HD) between two corresponding values in the same register or Hamming Weight (HW) of a specific value. •Step 2: Measure the power consumption. Measure the power consumption of cryptographic devices when encrypting or decrypting different data blocks. •Step 3: Calculate hypothetical intermediate values. For each key hypothetical, the corresponding hypothetical intermediate value is calculated. •Step 4: Map the intermediate values to the power consumption value. •Step 5: Compare the hypothetical power consumption values with the power traces. The index corresponding to the
maximum correlation coefficient reveals the correct key index and time. The correlation is calculated as follows. Pearson correlation coefficient is denoted as c. Suppose the attacker gets M power traces, each with N sampling points. The power consumption value corresponding to the ith sampling point on the mth trace is denoted as tm,i (1≤m≤M, 1≤i ≤N). Based on the power consumption model, the power consumption hypothesis value corresponds to the mth trace under the key assumption k is denoted as hm,k (1≤m≤M, 1≤k≤K). Under the key assumption k, the correlation coefficient of the ith sampling point is calculated as follows:
( )( )
( ) ( ) , , 1 , 2 2
, , 1 1
M
m k k m i i m
k i M M
m k k m i i m m
h h t t
c
h h t t
=
= =
− − =
− −

  (1)
where kh and it are the average of the power consumption model and the actual power consumption at the ith sampling point respectively. b. experiment layout The experimental platform mainly includes an attack target, fault injection controller, oscilloscope monitoring module, and data acquisition and processing module[18], as shown in Fig. 1. We conduct a large number of fault injection attacks and establish fault probability traces[18] which are used in subsequent analyses. iii. fault correlation analysis based on fault probability  a. scheme design For the Advanced Encryption Standard algorithm (AES), attackers usually choose the sampling points near the S-box transformation operation as attack points, showing strong correlations between the actual power consumption and the power consumption model. Taking the AES-128 algorithm as an example to implement FPFCA, as shown in Fig. 2. We conduct mass fault injection attacks on the output of the first S-box in the first round of encryption and establish the fault probability traces. If the first
This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/
3
byte of the key is recovered, the attack is successful. The recovery of other bytes of the key is similar; attack the output of other S-boxes in the first round of encryption. FPFCA attacks take advantage of the data dependency of cryptographic device faults. Many fault probability traces are used to analyze the fault probability at specific points, which is regarded as a function of the data being processed. In all subsequent discussions, it is assumed that the pro-
cessed data are subject to a uniform distribution. The steps of FPFCA are as follows: •Step 1: Select an intermediate value of the executed algorithm. The intermediate value must be a function f(d, k), where d represents non-constant data, and k represents a small part of the key. We choose the plaintext as d and the first byte of the key as k. •Step 2: Establish the fault probability traces. We calculate the fault probability of cryptographic devices when encrypting or decrypting M different data blocks. These plaintexts are recorded as vectors 1 2 ( , , , ) M
m m m ′= ⋯m , where mi represents a value corresponding to the ith encryption or decryption operation. Many fault injection attacks are carried out on each mi, and the corresponding fault probability trace is established as
,1 ,2 , ( , , , ) i i i i N p p p′ = ⋯p , where N represents the length of the
fault probability trace. The attacker establishes a fault probability trace for each of the M data. These fault probability traces are denoted as a matrix PM×N. •Step 3: Calculate the hypothetical intermediate value. For each possible key k, the corresponding hypothetical intermediate value is calculated, denoted as 1 2 ( , , , ) K
k k k= ⋯k , where K represents the number of all possible values of k. Given the data m and the key hypothesis k, the hypothetical intermediate value can be calculated for all M encryptions and all K key assumptions: ( ), ,i j i jv f m k= (1≤i≤M, 1≤j≤K). It is obtained that the matrix VM×K. The jth column of V contains all the intermediate values calculated by the key hypothesis kj. In fact, the cryptographic device uses only one element in k, which is denoted as kc. Our target is to find the kc, that is, to determine which column of V the device is dealing with during the M encryption or decryption. •Step 4: Map the intermediate value to the fault probability. The hypothetical intermediate value V is mapped to the hypothetical fault probability matrix H by the HW model. •Step 5: Compare the hypothetical fault probability value and the fault probability trace. Each column hi of matrix H and each column pj of matrix P are compared. The attacker compares the hypothetical fault probability value corresponding to each key hypothesis with the fault probability trace recorded at each location. The result of the comparison is a matrix CK× P, where each element ci,j contains the comparison of the columns hi and pj. The higher the value of ci, j, the higher the matching degree of the columns hi and pj. The jth sampling point on the mth fault probability trace is denoted as pm,j (1≤m≤M, 1≤j≤N). Based on the FPHW model[18], the hypothetical value of fault probability corresponding to the mth trace under the key assumption i is denoted as hm,i: , ( (plaintext ))m i mh HW Sbox i= ⊕ (2) where HW represents the HW of the S-box output. Under the key assumption i, the correlation coefficient of
the jth sampling point is denoted as ci,j :
( )( ) ( ) ( ) , , 1 , 22
, , 1 1
M
m i i m j j
m
i j M M
m i i m j j m m
h h p p
c
h h p p
=
= =
− − =
− −

  (3)
where ih and j p represents the average values of the FPHW model and the actual fault probability at the ith sampling point, respectively. By finding the maximum value of matrix C, the attacker can determine the correct key index kc and time index tc. The index of the maximum value is the result of the CPA attack. b. attack result We set the initial key to 0x04, conduct many fault injection attacks on 1000 random plaintexts, and establish fault probability traces. In the FPHW model [18], there is a negative correlation between the fault probability and HW, so the closer the correlation coefficient in the attack result is to -1, the stronger the correlation is. This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/
4
We randomly select 6 plaintexts to attack and get 6 fault probability traces. The correlation coefficient results of sampling points on the traces calculated by Eq. (3) are shown in Fig. 3. When the candidate keys are 4,67,127, the correlation coefficient is the minimum value of -0.98. For that the candidate key is not unique, the key fails to recover. Next, we randomly select 8 plaintexts to attack, and get 8 fault probability traces. The correlation coefficient results of sampling points on the traces and the correlation coefficient results calculated by Eq. (3) are shown in Fig. 4. When the candidate key is 0x04, the correlation coefficient is the minimum value of -1, and the key is recovered successfully. Under this method, the relationship between the success rate of key recovery and the number of fault probability traces is shown in Fig. 5. It can be seen that when the number of fault probability traces is 13 or more, the attacker has a 100% chance of recovering the key. c. analysis In the attack process, we establish the fault probability trace based on the FPHW model and align multiple data groups by introducing trigger signals. Therefore, there is no need for realignment and noise reduction, significantly reducing the difficulty of data processing. The computational complexity of the FPFCA algorithm is
denoted as λ:
16 256 M Nλ = × × × (4). FIGURE 5. The relationship between the success rate and the number of fault probability traces. According to the results of attack experiments, the computational complexity of the FPFCA algorithm is 1.06 × 107 by substituting M = 200 and N =13. Compared with the existing CPA methods, the computational complexity of FPFCA has been significantly reduced, but the number of iterations is still significant. Therefore, we consider improving the calculation efficiency by lowering the values of M and N.
The calculation complexity is too high, which is mainly caused by a large amount of data redundancy in the selection of sampling points (M) and random plaintext (N) on the fault probability trace:
First, there are too many sampling points in the fault probability trace. The subkey only affects the fault probability in a few moments, so not all sampling points are essential in calculating correlation. Combined with the data dependence of fault probability, we need to locate the output of the S-box more accurately and reduce the search range of sampling points by selecting the sampling points with the prominent peak of fault probability trace as POIs. Second, there is much redundancy in selecting random plaintexts. All the sampling points in the fault probability
2 4 6 8 10 12 14 16 18 20
Fault Probability Trace Number
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
S u
cc es
s R
at e
This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/
5
traces are required to calculate the hypothetical intermediate value. Hence, the number of iterations in the calculation is enormous. The HW of single-byte data obeys the binomial distribution. Tab. I shows the probability distribution of HW for uniformly distributed 8-bit data. The data with HW of 0 and 8 have the slightest probability of occurrence, and those with HW of 4 have the highest probability of occurrence. Therefore, there must be much repetition in the randomly selected plaintexts. The experiments show that the difference in fault probability corresponding to the S-box output with the same HW is almost the same, as shown in Tab. II. If we select the plaintexts whose S-box outputs are of the same HW, column vectors of the hypothetical intermediate value mapped by the HW model are the same, and the corresponding fault probability traces are almost the same. In this case, it is impossible to recover the key. Therefore, we consider selecting plaintexts whose S-box outputs are of different
HW, which can reduce the computational redundancy significantly. iv. fault correlation analysis based on secondary Filtering a. scheme design Based on the above considerations, we use fewer fault probability traces and more accurate POIs to reduce the number of iterations. We improve the FPFCA scheme and propose a fault correlation analysis attack based on secondary filtering (2FFPCA). This method classifies and selects plaintexts based on HW and selects POIs more accurately, which dramatically reduces the calculation amount. The specific steps are shown in Fig. 6. The steps of 2F-FPCA are as follows: •Step 1: Select the output value of the first S-box in the first round of encryption in the AES-128 algorithm as the intermediate value. •Step 2: Select plaintexts randomly and inject many voltage glitches in the encryption process to establish the fault probability traces. For each possible key ki (1≤i≤K), perform steps 3-5:. • Step 3: Calculate the hypothetical intermediate value. Given 1 2( , , , )Mm m m ′= ⋯m , calculate the corresponding hypothetical intermediate value ( ), ,i j i jv f m k= (1≤i≤M, 1 ≤j≤K). •Step 4: Map the intermediate value to the fault probability. The hypothetical intermediate value vi=(v1,i,v2,i,…,vM,i) is mapped to the hypothetical fault probability hi=(h1,i,h2,i,…,hM,i) by the FPHW model. Remove the same value in hi and get hi'=(h1,i',h2,i',…,hT,i'). •Step 5: Compare the hypothetical fault probability value and the fault probability trace. Select the set of fault probability traces Pi'=(p1',p2',…,pT') corresponding to hi', where pi'=(pi,1',pi,2',…,pi,R') is the fault probability trace after POI selection. Compare hi'and every column of Pi'and get ci'=(ci,1',ci,2',…,ci,R'), which maximum value is denoted as ci'. The maximum is denoted as c' = max{ c1', c2',…, cK'} for all the ci',. The key ki' corresponding to c' is the correct key. This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/
6
FIGURE 6. Attack flow of 2F-FPCA. b. attack process According to the above scheme, we attack the implementation of the AES-128 algorithm based on MCU. The attack process is described in detail with the initial key of 0x03. 1)POI Selection To reduce the computational complexity, we select the POIs in the fault probability trace to find the sampling points with the strongest correlation with the attack point to carry out subsequent attacks. From the above model verification results, we can see that the fault probability traces have a high degree of discrimination, so we first classify the attack traces based on the HW of the output data. Then, the summary of the difference method (SOD) is used to select the POIs. For the fault probability traces ( )Trac 0, ,9i i = ⋯ with HW ( 0,1, ,8)i i = ⋯ , calculate
( ) 1 2
1 2 1
7 8
0 1
Trac Trac i i
i i i SOD = = +
= −  (5). The SOD values of each sampling point are shown in Fig. 7. The higher the SOD value, the more significant the correlation between the sampling point and HW, so we selected 2900, 2904, 2908, 2912, and 2916ns as POIs. 2) random plaintexts selection We still choose the output of the first S-box in the first round of encryption as the intermediate value and inject many voltage glitches near the attack point. Find its maximum ci' for each possible key hypothesis value ki (1≤i≤K). Take k4 = 0x03 as an example to illustrate the attack process. The hypothetical fault probability is h4 = (5,5,5,4,3,5,3,3), and thus h4' = (5,4,3). The set of fault probability traces after filtering is
3
0.4533 0.5689 0.6389 0.5733 0.3844
0.4567 0.5689 0.6411 0.5744 0.3856
0.4611 0.5711 0.6500 0.5756 0.4033    ′ =       p . 3) Attack Result
Calculate that c3' = (-0.9973, -0.8660, -0.09443, -0.9997, - 0.8930), c3' = -0.9997. For all the ki(1≤i≤256), the corresponding ci' calculated by Eq. (3) is shown in Fig. 8. As can be seen that the correlation coefficient of key 0x03 is closest to -1, 0x03 is supposed to be the correct key. Thus, key recovery is successful. c. analysis Under the 2F-FPCA method, the relationship between the success rate of key recovery and the number of fault probability traces is shown in Fig. 9. The number of attack traces required for the proposed 2F-FPCA is less than that needed for FPFCA. When the number of fault probability traces is 10 or more, the attacker has a 100% chance of recovering the correct key. We select 10 plaintexts randomly for key recovery. Under each key assumption, only 4.45 traces are needed by selecting plaintexts to complete the key recovery on average. By substituting M = 4.45 and N = 5 into Eq. (4), the algorithm's computational complexity is calculated as 9.11 × 104. In recent years, some CPAs and improvement methods for
This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/
7
the AES-128 algorithm have been continuously proposed, such as CPA with biased power traces [13], CPA based on CPA with multiple filtering [19], and block CPA based on artificial intelligence [20]. Next, as shown in Tab. V, we compare the above CPA attack methods with the FPFCA and 2F-FPCA attack methods proposed in this paper. We propose two criteria for performance evaluation: the number of traces required to recover the full key and computational complexity. As described in Tab. V, the number of traces and sampling points required for the attack directly affects the computational complexity, consistent with Eq.(4). Therefore, the attacker must select the appropriate number of traces and sampling points to achieve high execution efficiency while considering the accuracy of key recovery. v. conclusion This paper proposes a fault correlation analysis method based on secondary filtering. Based on the AES-128 algorithm of the MCU, we conducted experiments and achieved key recovery using 10 fault probability traces. Compared with the existing CPA methods, 2F-FPCA has
the following advantages:
1) It is less affected by noise. We choose the FPHW model, which does not need to collect ciphertext and only pays attention to the response of the attack. 2) The correct key is of apparent characteristics. The correlation coefficient between the actual fault probability corresponding to the correct key and the hypothetical fault probability value based on the FPHW model is as high as -1. 3) The computational complexity is low. We select plaintexts with different HW of S-box output and POIs to reduce the number of traces and sampling points. Therefore, the computational complexity is significantly reduced, improving the attack efficiency. Due to the difference in cryptographic algorithms and selection methods, the selection results of POIs are different. At the same time, we consider expanding the
range of cryptographic algorithms targeted by attacks.