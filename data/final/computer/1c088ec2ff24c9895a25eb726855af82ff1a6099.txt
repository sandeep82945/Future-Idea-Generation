Community detection techniques are useful tools for social media platforms to discover tightly connected groups of users who share common interests. However, this functionality often comes at the expense of potentially exposing individuals to privacy breaches by inadvertently revealing their tastes or preferences. Therefore, some users may wish to safeguard their anonymity and opt out of community detection for various reasons, such as affiliation with political or religious organizations. In this study, we address the challenge of community membership hiding, which involves strategically altering the structural properties of a network graph to prevent one or more nodes from being identified by a given community detection algorithm.We tackle this problem by formulating it as a constrained counterfactual graph objective, and we solve it via deep reinforcement learning. We validate the effectiveness of our method through two distinct tasks: node and community deception. Extensive experiments show that our approach overall outperforms existing baselines in both tasks. 1 introduction In the ever-expanding landscape of interconnected entities, such as social networks, online platforms, and collaborative ecosystems, the identification of coherent communities plays a pivotal role in understanding complex network graph structures [9]. The task of identifying these communities is typically accomplished by running community detection algorithms on the network graphs, which allows the unveiling of hidden patterns and relationships among nodes within these structures. These algorithms effectively group entities, users, or objects based on shared characteristics or interactions, shedding light on the underlying organization and dynamics of the network. The successful detection of communities in complex network graphs is useful in several application domains [16]. For instance, the insights gained from accurately identifying communities can significantly impact business strategies, leading to better monetization opportunities through targeted advertising. By understanding the specific interests and behaviors of community members, businesses can provide better service solutions and tailor advertisements that are more relevant to their customer segments, resulting in higher engagement and increased revenue [26]. However, while community detection algorithms offer immense benefits, they also raise concerns regarding individual privacy and data protection. In some cases, certain nodes within the network
might prefer to remain undetected as part of any specific community. These nodes could belong to sensitive or private groups (e.g., political organizations or religious associations) or may simply wish to retain their anonymity for personal reasons. Anyway, the right to opt out of community detection becomes crucial to strike a balance between preserving privacy and maximizing the utility of these algorithms. Motivated by the need above, in this paper, we address the intriguing challenge of community membership hiding. Taking inspiration from the concept of counterfactual reasoning [36, 37], specifically for graph data [22], our objective is to offer users personalized recommendations to preserve their anonymity from community detection. We effectively guide them in adjusting their connections so that they cannot be identified as members of a given community. For instance, we might suggest to a hypothetical user of a social network, â€œIf you unfollow users X and Y, you will no longer be recognized as a member of community Z.â€
The core challenge of this problem lies in determining how to strategically modify the structural properties of a network graph, effectively excluding one or more nodes from being identified by a given community detection algorithm. To the best of our knowledge, we are the first to formulate the community membership hiding problem as a constrained counterfactual graph objective. Furthermore, inspired by [5], we cast this problem into a Markov decision process (MDP) framework and we propose a deep reinforcement learning (DRL) approach to solve it. Our method works as follows. We start with a graph and a set of communities identified by a specific community detection algorithm whose inner logic remains unknown or undisclosed. When given a target node within a community, our objective is to find the optimal structural adjustment of the target nodeâ€™s neighborhood. This adjustment should enable the target node to remain concealed when the same community detection algorithm is reapplied to the modified graph. We refer to this primary task as node deception, and we consider it successful when a predefined similarity threshold between the original community and the new community containing the target node is met. In addition to this, we define a community deception task â€“ already investigated in the literature [8] â€“ whose goal is to mask all the nodes of a given community. We validate our approach on three real-world datasets, and we demonstrate that it outperforms existing baselines using standard quality metrics both on node and community deception tasks. Furthermore, unlike their competitors, our method maintains its effectiveness even when used in conjunction with a community detection algorithm that was not seen during the training phase. The main contributions of our work are summarized below. ar X
iv :2
31 0. 08 90
9v 1
[ cs
.S I]
1 3
O ct
2 02
3
â€¢ We formulate the community membership hiding problem as a constrained counterfactual graph objective. â€¢ We cast this problem within an MDP framework and solved it via DRL. â€¢ We utilize a graph neural network (GNN) representation to capture the structural complexity of the input graph, which in turn is used by the DRL agent to make its decisions. â€¢ We validate the performance of our method in comparison with existing baselines using standard quality metrics both on node and community deception tasks. â€¢ We publicly release both the source code and the data utilized in this study to encourage reproducibility.1
The remainder of this paper is structured as follows. In Section 2, we review related work. Section 3 contains background and preliminaries. We present our problem formulation in Section 4. In Section 5, we describe our method, which we validate through extensive experiments in Section 6. Section 7 discusses the potential ethical impact of our method. Finally, we conclude in Section 8. 2 relatedwork  2.1 community detection Community detection algorithms are essential tools in network analysis, aiming to uncover densely connected groups of nodes within a graph. Their applications span various domains, including social network analysis, biology, and economics. These algorithms can be broadly categorized into two types: nonoverlapping and overlapping community detection. Non-overlapping community detection assigns each node to a single community, employing various techniques such as Modularity Optimization [1], Spectrum Analysis [34], Random Walk [30], or Label Propagation [31]. On the other hand, overlapping community detection seeks to better represent real-world networks where nodes can belong to multiple communities. Mature methods have been developed for this purpose, including NISE (Neighborhood-Inflated Seed Expansion) [40] and techniques centered around minimizing the Hamiltonian of the Potts model [33]. For a more comprehensive overview, we recommend consulting the work by Jin et al. [14] 2.2 community deception Community deception is closely related to the community membership hiding problem we investigate in this work. In fact, community deception can be seen as a specialization of community membership hiding, where the objective is to hide an entire community from community detection algorithms. Community deception can serve various purposes, such as preserving individualsâ€™ anonymity in online monitoring scenarios, like social networks, or aiding public safety by identifying online criminal activities. However, there is also a darker side to these techniques, as malicious actors can exploit them to evade detection algorithms and operate covertly, potentially violating the law. Several techniques exist for hiding communities, including those based on the concept of Modularity. Notable examples in this category include the algorithm proposed by Nagaraja [27], one of the pioneering approaches in this field, the DICE algorithm introduced
1https://anonymous.4open.science/r/community-deception-0618/
by Waniek et al. [39], and the algorithm developed by Fionda and PirrÃ² [8]. Other deception techniques are founded on the idea of Safeness, as defined by Fionda and PirrÃ² [8] and further explored by Chen et al. [4], as well as the concept of Permanence as developed by Mittal et al. [23]. For a more exhaustive summary of these methods, we suggest referring to [15]. 3 background and preliminaries In this section, we will briefly review the definition of the wellknown community detection problem. Afterward, we will utilize this definition as the foundation to provide our formulation of the community membership hiding problem. Let G = (V, E) be an arbitrary (directed) graph, where V is a set of ğ‘› nodes (|V| = ğ‘›), and E âŠ† V Ã— V is a set of ğ‘š edges (|E | = ğ‘š). Optionally, an additional set of ğ‘ node attributes may also be present. In such cases, each node ğ‘¢ âˆˆ V is associated with a corresponding ğ‘-dimensional real-valued feature vector ğ’™ğ‘¢ âˆˆ Rğ‘ . Furthermore, the underlying link structure of G is represented using a binary adjacency matrix ğ‘¨ âˆˆ {0, 1}ğ‘›Ã—ğ‘› , where ğ‘¨ğ‘¢,ğ‘£ = 1 if and only if the edge (ğ‘¢, ğ‘£) âˆˆ E, and it is 0 otherwise. The community detection problem aims to identify clusters of nodes within a graph, called communities. Due to the intricate nature of the concept and its reliance on contextual factors, establishing a universally accepted definition for a â€œcommunityâ€ is challenging. Intuitively, communities exhibit strong intra-cluster connections and relatively weaker inter-cluster connections [41]. More formally, in this work, we adhere to the definition widely used in the literature [8, 19, 21, 23], and we consider a function ğ‘“ (Â·) that takes a graph as input and generates a partition of its nodesV into a set of non-empty, non-overlapping, communities {C1, . . . , Cğ‘˜ } as output, i.e., ğ‘“ (G) = {C1, . . . , Cğ‘˜ }, where ğ‘˜ is usually unknown. Within this framework, every node ğ‘¢ âˆˆ V is assigned to exactly one community. This assignment can be captured using a ğ‘˜-dimensional stochastic vector ğ’„ğ‘¢ , where ğ‘ğ‘¢,ğ‘– = ğ‘ƒ (ğ‘¢ âˆˆ Cğ‘– ) measures the probability that node ğ‘¢ belongs to community Cğ‘– , andâˆ‘ğ‘˜ ğ‘–=1 ğ‘ğ‘¢,ğ‘– = 1. Eventually, we use the notation ğ‘– âˆ— ğ‘¢ = argmaxğ‘– (ğ‘ğ‘¢,ğ‘– ) to represent the index of the community to which a specific node ğ‘¢ belongs to based on the outcome of ğ‘“ (G). Note that in the case of hard node partitioning, there exists only one non-zero entry in the vector ğ’„ğ‘¢ , which evaluates to 1. However, this framework can be extended to scenarios with overlapping communities, where each node can belong to multiple clusters, resulting in more than one non-zero entry in ğ’„ğ‘¢ . We leave the exploration of overlapping communities for future work. Typically, community detection methods operate by maximizing a specific score that measures the intra-community cohesiveness (e.g., Modularity [29]). However, this usually translates into solving NP-hard optimization problems. Hence, some convenient approximations have been proposed in the literature to realize ğ‘“ (Â·) in practice, e.g., Louvain [1], WalkTrap [30], Greedy [2], InfoMap [3], Label Propagation [31], Leading Eigenvectors [28], Edge-Betweeness [11], SpinGlass [32]. Anyway, the rationale behind how communities are found is irrelevant to our task, and, hereinafter, we will treat the community detection technique ğ‘“ (Â·) as a â€œblack boxâ€. 4 community membership hiding In a nutshell, community membership hiding aims to enable a target node within a graph to elude being recognized as a member of a particular node cluster, as determined by a community detection algorithm. This objective is accomplished by granting the node in question the ability to strategically modify its connections with other nodes. Therefore, our primary focus is on making changes to the graphâ€™s structure, represented by the adjacencymatrix.While altering node features holds potential interest, that aspect is reserved for future exploration. We depict our approach in Fig. 1. 4.1 problem formulation Let G = (V, E) be a graph and ğ‘“ (G) = {C1, . . . , Cğ‘˜ } denote the community arrangement derived from applying a detection algorithm ğ‘“ (Â·) to G. Furthermore, suppose that ğ‘“ has identified node ğ‘¢ âˆˆ V as a member of the community Cğ‘– âˆˆ ğ‘“ (G) â€“ i.e., ğ‘–âˆ—ğ‘¢ = ğ‘– â€“ denoted as ğ‘¢ âˆˆ Cğ‘– . The aim of community membership hiding is to formulate a function â„ğœ½ (Â·), parametrized by ğœ½ , that takes as input the initial graph G and produces as output a new graph â„ğœ½ (G) = Gâ€² = (V, Eâ€²). Among all the possible graphs, we seek the one which, when input to the community detection algorithm ğ‘“ , disassociates a target node ğ‘¢ from its original community Cğ‘– . To achieve that goal, suppose that the target nodeğ‘¢ is associated with a new community Câ€²
ğ‘– âˆˆ ğ‘“ (Gâ€²). Hence, we can define the objective of
community membership hiding by establishing a threshold for the similarity between Câ€²
ğ‘– and Cğ‘– , excluding the target node ğ‘¢, which,
by definition, belongs to both communities. In other words, we set a condition: ğ‘ ğ‘–ğ‘š(Cğ‘– âˆ’ {ğ‘¢}, Câ€²ğ‘– âˆ’ {ğ‘¢}) â‰¤ ğœ , where ğœ âˆˆ [0, 1]. 2
Several similarity measures can be used to measure ğ‘ ğ‘–ğ‘š(Â·, Â·) depending on the application domain, e.g., the overlap coefficient 2We assume ğ‘ ğ‘–ğ‘š ( Â·, Â· ) ranges between 0 and 1. (a.k.a. Szymkiewiczâ€“Simpson coefficient) [24], the Jaccard coefficient [13], and the SÃ¸rensen-Dice coefficient [6]. Setting ğœ = 0 represents the most stringent scenario, where we require zero overlaps between Câ€²
ğ‘– and Cğ‘– , except for the nodeğ‘¢ itself. At the other extreme, when ğœ = 1, we adopt a more tolerant strategy, allowing for maximum overlap between Câ€²
ğ‘– and Cğ‘– . However, it is
important to note that except for the overlap coefficient, which can yield a value of 1 even if one community is a subset of the other, the Jaccard and SÃ¸rensen-Dice coefficients yield a value of 1 only when the two communities are identical. In practice, setting ğœ = 1 may lead to the undesired outcome of Câ€²
ğ‘– being equal to Cğ‘– , thus
contradicting the primary goal of community membership hiding. Therefore, it is common to let ğœ âˆˆ [0, 1) to avoid this scenario. Moreover, it is essential to emphasize that executing ğ‘“ on Gâ€² instead of the original G could potentially influence (ğ‘–) the community affiliations of nodes beyond the selected target, ğ‘¢, and (ğ‘–ğ‘–) the eventual count of recognized communities (i.e., |ğ‘“ (Gâ€²) | = ğ‘˜â€² â‰  ğ‘˜ = |ğ‘“ (G)|), providing that ğ‘“ does not need this number fixed apriori as one of its inputs. Therefore, community membership hiding must strike a balance between two conflicting goals. On the one hand, the target node ğ‘¢ must be successfully elided from the original community Cğ‘– ; on the other hand, the cost of such an operation â€“ i.e., the â€œdistanceâ€ between G and Gâ€², and between ğ‘“ (G) and ğ‘“ (Gâ€²) â€“ must be as small as possible. Overall, we can define the following loss function associated with the community membership hiding task:
L(â„ğœ½ ;G, ğ‘“ , ğ‘¢) = â„“decept (G, â„ğœ½ (G); ğ‘“ ,ğ‘¢) + ğœ†â„“dist (G, â„ğœ½ (G); ğ‘“ ). (1)
The first component (â„“decept) penalizes when the goal is not satisfied. Let Î“ be the set of input graphs which do not meet the membership hiding objective, i.e., those which retain node ğ‘¢ as part of the community Cğ‘– . More formally, let CÌƒğ‘– be the community to which node ğ‘¢ is assigned when ğ‘“ is applied to the input graph GÌƒ. We define Î“ = {GÌƒ | ğ‘ ğ‘–ğ‘š(Cğ‘– âˆ’ {ğ‘¢}, CÌƒğ‘– âˆ’ {ğ‘¢}) > ğœ}. Thus, we can compute â„“decept as follows:
â„“decept (G, â„ğœ½ (G); ğ‘“ ) = 1Î“ (â„ğœ½ (G)), (2)
where 1Î“ (â„ğœ½ (G)) is the well-known 0-1 indicator function, which evaluates to 1 if â„ğœ½ (G) âˆˆ Î“, or 0 otherwise. The second component, denoted as â„“dist, is a composite function designed to assess the overall dissimilarity between two graphs and their respective communities found by ğ‘“ . This function serves the dual purpose of (ğ‘–) discouraging the new graph â„ğœ½ (G) from diverging significantly from the original graph G and (ğ‘–ğ‘–) preventing the new community structure ğ‘“ (â„ğœ½ (G)) from differing substantially from the prior community structure ğ‘“ (G). 4.2 counterfactual graph objective Given the target community Cğ‘– , from which we want to exclude node ğ‘¢, we can classify the remaining nodesV âˆ’ {ğ‘¢} of G into two categories: nodes that are inside the same community Cğ‘– as ğ‘¢ and nodes that belong to a different community from ğ‘¢. This categorization helps us define which edges the target node ğ‘¢ can control and, thus, directly manipulate under the assumption that G is a directed graph.3 Specifically, following [8], we assume that ğ‘¢ can (ğ‘–) remove
3We can easily extend this reasoning if G is undirected. existing outgoing edges to nodes that are inside ğ‘¢â€™s community (ğ‘–ğ‘–) add new outgoing edges to nodes that are outside ğ‘¢â€™s community. We intentionally exclude two possible actions: (ğ‘–ğ‘–ğ‘–) removing outgoing links to outside-community nodes and (ğ‘–ğ‘£) adding outgoing links to inside-community nodes. Two primary reasons drive this choice. On the one hand, allowing (ğ‘–ğ‘–ğ‘–) could isolate ğ‘¢ and its original community Cğ‘– further. On the other hand, allowing (ğ‘–ğ‘£) would enhance connectivity between ğ‘¢ and other nodes in Cğ‘– . Both events contradict the goal of community membership hiding. Overall, we can define the set of candidate edges to remove (Eâˆ’ ğ‘¢,ğ‘–
) and to add (E+
ğ‘¢,ğ‘– ) as follows. Eâˆ’ğ‘¢,ğ‘– = {(ğ‘¢, ğ‘£) | ğ‘¢, ğ‘£ âˆˆ Cğ‘– âˆ§ (ğ‘¢, ğ‘£) âˆˆ E}, E+ğ‘¢,ğ‘– = {(ğ‘¢, ğ‘£) | ğ‘¢ âˆˆ Cğ‘– , ğ‘£ âˆ‰ Cğ‘– âˆ§ (ğ‘¢, ğ‘£) âˆ‰ E}. If we suppose the target node ğ‘¢ has a fixed budget ğ›½ > 0, we can find the optimal model â„âˆ— = â„ğœ½ âˆ— as the one whose parameters ğœ½ âˆ— minimize Eq. (1), i.e., by solving the following constrained objective:
ğœ½ âˆ— = arg min ğœ½
{ L(â„ğœ½ ;G, ğ‘“ , ğ‘¢) } subjetc to: |Bğ‘¢,ğ‘– | â‰¤ ğ›½,
(3)
where Bğ‘¢,ğ‘– âŠ† Eâˆ’ğ‘¢,ğ‘– âˆª E + ğ‘¢,ğ‘–
is the set of graph edge modifications selected from the candidates. Note that Eq. (3) resembles the optimization task to find the best counterfactual graph Gâˆ— = â„âˆ— (G) that, when fed back into ğ‘“ , changes its output to hide the target node ğ‘¢ from its community. 4.3 markov decision process The community membership hiding problem defined in Eq. (3) requires minimizing a discrete, non-differentiable loss function. As such, standard optimization methods like stochastic gradient descent are unsuitable for this task. One potential solution involves smoothing the loss function using numerical techniques, such as applying a real-valued perturbation matrix to the original graphâ€™s adjacency matrix like in [22, 38]. We leave the exploration of these smoothing techniques for future work. Instead, we take a different approach and cast this problem as a sequential decision-making process, following standard reinforcement learning principles. In this framework, at each time step, an agent: (i) takes an action (choosing to add or remove an edge based on the rules defined above), and (ii) observes the new set of communities output by ğ‘“ when this is fed with the graph modified according to the action taken before. The agent also receives a scalar reward from the environment. The process continues until the agent eventually meets the specified deception goal and the optimal counterfactual graph Gâˆ— â€“ i.e., the optimal â„âˆ— â€“ is found. We formalize this procedure as a typical Markov decision process (MDP) denoted asM = {S,A,P, ğ‘0, ğ‘Ÿ , ğ›¾}. Below, we describe each component of this framework separately. States (S). At each time step ğ‘¡ , the agentâ€™s state is ğ‘†ğ‘¡ = ğ‘ ğ‘¡ , where ğ‘ ğ‘¡ = Gğ‘¡ âˆˆ S is the current modified input graph. In practice, though, we can replace Gğ‘¡ with its associated adjacency matrix ğ‘¨ğ‘¡ âˆˆ {0, 1}ğ‘›Ã—ğ‘› . Initially, when ğ‘¡ = 0, G0 = G (ğ‘¨0 = ğ‘¨). Actions (A). The set of actions is defined by A = {ğ‘ğ‘¡ }, which consists of all valid graph rewiring operations, assuming node ğ‘¢
belongs to the community ğ¶ğ‘– . A = {del(ğ‘¢, ğ‘£) | (ğ‘¢, ğ‘£) âˆˆ Eâˆ’ğ‘¢,ğ‘– } âˆª {add(ğ‘¢, ğ‘£) | (ğ‘¢, ğ‘£) âˆˆ E + ğ‘¢,ğ‘– }. (4)
According to the allowed graph modifications outlined in Section 4.2, the agent can choose between two types of actions: deleting an edge from ğ‘¢ to any node within the same community ğ¶ğ‘– or adding an edge from ğ‘¢ to any node in a different community. Transitions Probability (P). Let ğ‘ğ‘¡ âˆˆ A be the action taken by the agent at iteration ğ‘¡ . This action deterministically guides the agentâ€™s transition from the state ğ‘ ğ‘¡ to the state ğ‘ ğ‘¡+1. In essence, the transition function P : S Ã— A Ã— S â†’ [0, 1], which associates a transition probability with each state-action pair, assigns a transition probability of 1 when the subsequent state ğ‘ ğ‘¡+1 is determined by the state-action pair (ğ‘ ğ‘¡ , ğ‘ğ‘¡ ) and 0 otherwise. Formally:
â€¢ P(ğ‘ ğ‘¡+1 |ğ‘ ğ‘¡ , ğ‘ğ‘¡ ) = 1 if ğ‘ ğ‘¡+1 is the next state resulting from the application of action ğ‘ğ‘¡ in state ğ‘ ğ‘¡ . â€¢ P(ğ‘ ğ‘¡+1 |ğ‘ ğ‘¡ , ğ‘ğ‘¡ ) = 0 otherwise. Reward (ğ‘Ÿ ). The reward function of the action ğ‘ğ‘¡ which takes the agent from state ğ‘ ğ‘¡ to state ğ‘ ğ‘¡+1 can be defined as:
ğ‘Ÿ (ğ‘ ğ‘¡ , ğ‘ğ‘¡ ) = { 1 âˆ’ ğœ†(â„“ğ‘¡dist âˆ’ â„“ ğ‘¡âˆ’1 dist ) , if â€œthe goal is metâ€
âˆ’ğœ†(â„“ğ‘¡dist âˆ’ â„“ ğ‘¡âˆ’1 dist ) , otherwise. (5)
The goal is considered successfully achieved when ğ‘“ (Gğ‘¡ ) leads to ğ‘¢ âˆˆ Cğ‘¡
ğ‘– â‰  Cğ‘– such that ğ‘ ğ‘–ğ‘š(Cğ‘– âˆ’ {ğ‘¢}, Cğ‘¡ğ‘– âˆ’ {ğ‘¢}) â‰¤ ğœ . In addition,
â„“ğ‘¡dist = â„“dist (G,G ğ‘¡ ; ğ‘“ ) measures the penalty computed on the graph before and after action ğ‘ğ‘¡ , and ğœ† âˆˆ R>0 is a parameter that controls its weight. More precisely, the penalty is calculated as follows:
â„“dist (G,Gğ‘¡ ; ğ‘“ ) = ğ›¼ Ã— ğ‘‘community + (1 âˆ’ ğ›¼) Ã— ğ‘‘graph, (6) where ğ‘‘community computes the distance between the community structures ğ‘“ (G) and ğ‘“ (Gğ‘¡ ), ğ‘‘graph measures the distance between the two graphs G and Gğ‘¡ , and the parameter ğ›¼ âˆˆ [0, 1] balances the importance between the two distances. Hence, the reward function encourages the agent to take actions that preserve the similarity between the community structures and the graphs before and after the rewiring action. Policy (ğœ‹ğœ½ ).We first define a parameterized policy ğœ‹ğœ½ that maps from states to actions. We then want to find the values of the policy parameters ğœ½ that maximize the expected reward in the MDP. This is equivalent to finding the optimal policy ğœ‹âˆ—, which is the policy that gives the highest expected reward for any state. We can find the optimal policy ğœ‹âˆ— by minimizing the Eq. (3). This minimization leads to the discovery of the optimal model â„âˆ—, which is the model that best predicts the rewards in the MDP. ğœ½ âˆ— = arg min ğœ½ â„“decept (â„ğœ½ ;G, ğ‘“ , ğ‘¢) + ğœ†â„“dist (G, â„ğœ½ (G); ğ‘“ )
= arg max ğœ½ âˆ’ â„“decept (â„ğœ½ ;G, ğ‘“ , ğ‘¢) âˆ’ ğœ†â„“dist (G, â„ğœ½ (G); ğ‘“ )
= arg max ğœ½
{ 1 âˆ’ ğœ†(â„“ğ‘¡dist âˆ’ â„“ ğ‘¡âˆ’1 dist ) , if â€œthe goal is metâ€
âˆ’ğœ†(â„“ğ‘¡dist âˆ’ â„“ ğ‘¡âˆ’1 dist ) , otherwise
= arg max ğœ½ ğ‘‡âˆ‘ï¸ ğ‘¡=1 ğ‘Ÿ (ğ‘ ğ‘¡ , ğœ‹ğœ½ (ğ‘ ğ‘¡ )),
(7)
where ğ‘‡ is the maximum number of steps per episode taken by the agent and is therefore always less than the allowed number of graph manipulations, i.e., ğ‘‡ â‰¤ ğ›½ . 5 proposed method To learn the optimal policy for our agent defined above, we use the Advantage Actor-Critic (A2C) algorithm [25], a popular deep reinforcement learning technique that combines the advantages of both policy-based and value-based methods. Specifically, A2C defines two neural networks, one for the policy function (ğœ‹ğœ½ ) and another for the value function estimator (ğ‘‰ğ‘£ ), such that:
âˆ‡ğœ½J (ğœ½ ) âˆ¼ ğ‘‡âˆ’1âˆ‘ï¸ ğ‘¡=0 âˆ‡ğœ½ logğœ‹ğœ½ (ğ‘ğ‘¡ |ğ‘ ğ‘¡ )ğ´(ğ‘ ğ‘¡ , ğ‘ğ‘¡ ),
with ğ´(ğ‘ ğ‘¡ , ğ‘ğ‘¡ ) = ğ‘Ÿğ‘¡+1 + ğ›¾ğ‘‰ğ‘£ (ğ‘ ğ‘¡+1) âˆ’ğ‘‰ğ‘£ (ğ‘ ğ‘¡ ),
where J (ğœ½ ) is the reward function, and the goal is to find the optimal policy parameters ğœ½ that maximize it.ğ´(ğ‘ ğ‘¡ , ğ‘ğ‘¡ ) is the advantage function that quantifies how good or bad an action ğ‘ğ‘¡ is compared to the expected value of actions chosen based on the current policy. Below, we describe the policy (actor) and value function network (critic) separately. The full details of how our agent is trained are provided in Appendix A. 5.1 policy function network (actor) The policy function network is responsible for generating a probability distribution over possible actions based on the input, which consists of a list of nodes and the graphâ€™s feature matrix. However, some graphs may lack node features. In such cases, we can extract continuous node feature vectors (i.e., node embeddings) with graph representational learning frameworks like node2vec [12]. These node embeddings serve as the feature matrix. Our neural network implementation comprises a primary graph convolution layer (GCNConv [17]) for updating node features. The output of this layer, along with skip connections, feeds into a block consisting of three hidden layers. Each hidden layer includes multilayer perception (MLP) layers, ReLU activations, and dropout layers. The final output is aggregated using a sum-pooling function. In building our network architecture, we were inspired, in part, by the work conducted by Gammelli et al. [10], adapting it to our task. The policy is trained to predict the probability that node ğ‘£ is the optimal choice for adding or removing the edge (ğ‘¢, ğ‘£) to hide the target node ğ‘¢ from its original community. The feasible actions depend on the input node ğ‘¢ and are restricted to a subset of the graphâ€™s edges as outlined in Section 4.2. Hence, not all nodes ğ‘£ âˆˆ V are viable options for the policy. 5.2 value function network (critic) This network resembles the one employed for the policy, differing only in one aspect: it incorporates a global sum-pooling operation on the convolution layerâ€™s output. This pooling operation results in an output layer with a size of 1, signifying the estimated value of the value function. The role of the value function is to predict the state value when provided with a specific action ğ‘ğ‘¡ and state ğ‘ ğ‘¡ . 6 experiments  6.1 experimental setup Datasets. To keep the training time for our DRL agent computationally feasible, we train it on the real dataset words,4 This dataset strikes a favorable balance in terms of the number of nodes, edges, and discovered communities. A swift growth in the number of nodes and edges would lead to an exponential rise in potential actions for the agent. This, in turn, would result in impractical training times given our computational resources. In addition, we evaluate the performance of our method on two additional datasets: kar4 and Wikipediaâ€™s vote.5
Community Detection Algorithms. The DRL agent is trained using a single detection algorithm, i.e., our ğ‘“ (Â·), namely themodularitybased Greedy (greedy) algorithm [2]. At test time, we employ two additional algorithms. One of them, the Louvain (louvain) algorithm [1], falls within the same family as the one used for training. The other, the WalkTrap (walktrap) [30], takes a distinct approach centered on Random Walks. Table 1 provides an overview of the datasets used, including key properties and the number of communities detected by each community detection algorithm. The modularity-based algorithms (greedy and louvain) yield comparable community counts, while walktrap identifies a generally higher number of communities. Similarity/Distance Metrics. To assess the achievement of the goal, i.e., whether the new community Cğ‘¡
ğ‘– of node ğ‘¢ at step ğ‘¡ can
no longer be considered the same as the initial community Cğ‘– , we need to define the ğ‘ ğ‘–ğ‘š(Â·) function used within â„“decept. We employ the SÃ¸rensen-Dice coefficient [6], which is defined as follows:
DSC(Cğ‘– , Cğ‘¡ğ‘– ) = 2|Cğ‘–
â‹‚Cğ‘¡ ğ‘– |
|Cğ‘– | + |Cğ‘¡ğ‘– | . (8)
This metric returns a value between 0 (no similarity) and 1 (strong similarity). If that value is less than or equal to the parameter ğœ , we consider the deception goal successfully met. Furthermore, as described in Eq. (6), we must specify the penalty function (â„“dist), which consists of two mutually balanced factors, namelyğ‘‘community andğ‘‘graph. These factors quantify the dissimilarity between community structures and graphs before and after the action. During model training, we operationalize these distances using the Normalized Mutual Information (NMI) score for community comparison and the Jaccard distance for graph comparison. The NMI score [18, 35], utilized for measuring the similarity between community structures, ranges from 0 (indicating nomutual information) to 1 (indicating perfect correlation). 4http://konect.cc/ 5https://networkrepository.com
Following the formulation by [20], it can be expressed as follows:
NMI(K,Kğ‘¡ ) = ğ¼norm (ğ‘‹ : ğ‘Œ ) = ğ» (ğ‘‹ ) + ğ» (ğ‘Œ ) âˆ’ ğ» (ğ‘‹,ğ‘Œ )
(ğ» (ğ‘‹ ) + ğ» (ğ‘Œ ))/2 , (9)
where ğ» (ğ‘‹ ) and ğ» (ğ‘Œ ) denote the entropy of the random variables ğ‘‹ and ğ‘Œ associated with partitions K = ğ‘“ (G) and Kğ‘¡ = ğ‘“ (Gğ‘¡ ), respectively, while ğ» (ğ‘‹,ğ‘Œ ) denotes the joint entropy. Since we need to transform this metric into a distance, we calculate 1-NMI. The Jaccard distance can be adapted to the case of two graphs, as described in [7], as follows:
Jaccard(G,Gğ‘¡ ) = |G â‹ƒGğ‘¡ | âˆ’ |Gâ‹‚Gğ‘¡ | |Gâ‹ƒGğ‘¡ | = âˆ‘ ğ‘–, ğ‘— |ğ‘¨ğ‘–, ğ‘— âˆ’ğ‘¨ğ‘¡ğ‘–, ğ‘— |âˆ‘ ğ‘–, ğ‘— max(ğ‘¨ğ‘–,ğ‘— ,ğ‘¨ğ‘¡ğ‘–,ğ‘— ) ,
(10) where ğ‘¨ğ‘–, ğ‘— denotes the (ğ‘–, ğ‘—)-th entry of the adjacency matrix for the original graph G. The Jaccard distance yields a value of 0 when the two graphs are identical and 1when they are entirely dissimilar. Tasks. We validate our method on two separate tasks: node deception and community deception. The former directly stems from the community membership hiding problem defined in Section 4. Its goal is to conceal an individual node from the community to which it was initially identified. The latter, instead, can be seen as a specific instance of node deception, where the objective is to hide an entire community from a designated detection algorithm. In essence, this involves performing multiple node deception tasks, one for each node within the community to be masked. Actually, this is a simplification of the process since each node deception task may indirectly hide other nodes within the same community. 6.2 node deception task Baselines. 1) Random-based. This baseline operates by randomly selecting one of the nodes in the graph. If the selected node is a neighbor of the node to be hidden (i.e., there is an edge between them), the edge is removed; otherwise, it is added. The randomness of these decisions aims to obscure the nodeâ€™s true community membership. 2) Degree-based. This approach adopts a different strategy for node concealment. Specifically, it selects nodes with the highest degrees within the graph and rewires them. By prioritizing nodes with higher degrees, this baseline seeks to disrupt the nodeâ€™s central connections within its initial community, thus promoting concealment. 3) Roam-based. Our third baseline is based on the Roam heuristics [39], originally designed to reduce a nodeâ€™s centrality within the network. This hiding approach aims to diminish the centrality and influence of the target node within its initial community, making it less conspicuous and favoring its deception. Evaluation Metrics.We measure the performance of each method in solving the node deception task using the following metrics. 1) Success Rate (SR). This metric calculates the success rate of the node deception algorithm by determining the percentage of times the target node is successfully hidden from its original community. If, after applying the node deception algorithm, the target node no longer belongs to the original community (as per Eq. (8) and the ğœ constraint), we consider the goal achieved. By repeating this procedure for several nodes and communities, we can estimate the algorithmâ€™s success rate. Obviously, a higher value of this metric indicates better performance. 2) Normalized Mutual Information (NMI). To quantify the impact of the functionâ„ğœ½ (Â·) on the resulting community structure, denoted as the output of ğ‘“ (Gâ€²) where Gâ€² is the graph created by modifying the original graph G, we compute NMI(K,Kâ€²), as outlined in Eq. (9). This score measures the similarity between the two structures, K = ğ‘“ (G) andKâ€² = ğ‘“ (Gâ€²). A higher value for this metric indicates a greater degree of similarity between the original and modified community structures. 6.3 community deception task Description. We adapt our method, originally conceived for the node deception task, to the community deception task as follows. We iterate the execution of our agent on every node of the community to hide. In doing so, we fulfill the constraint on the number of possible actions (i.e., graph rewirings). Specifically, we set the same constraint as in [8], which limits the percentage of edges of the graph that can be modified. To make more efficient use of its budget, our agent, at each step, ranks the nodes within the community to hide based on their centrality degrees, starting with the most central node and progressing to the least central. This selection process prioritizes highly central nodes; hence, the agent is more likely to mask more nodes within the target community using the same budget compared to selecting nodes randomly. In the next step, based on the number of actions performed, the agent chooses another node to hide from the remaining nodes within the target community, with the budget adjusted accordingly. We describe this procedure in Algorithm 1, provided in Appendix B. Baselines.We compare our method with two of the most popular community deception algorithms available in the literature, both proposed in [8]. Those are Modularity-based and Safeness-based. Evaluation Metrics. We validate the quality of each method considered by comparing the community structures obtained before and after applying the node deception function â„ğœ½ (Â·). In particular, we calculate the Deception Score as defined in [8] and the NMI described in Eq. (9). The Deception Score (H ) evaluates the level of concealment of a set of nodes Cğ‘– , within a community structure K identified by a detection algorithm ğ‘“ (Â·), i.e., K = ğ‘“ (G). It is defined as follows:
H(Cğ‘– ,K) = ( 1 âˆ’ |ğ‘† (Cğ‘– ) | âˆ’ 1|Cğ‘– | âˆ’ 1 ) Ã—[
1 2 (1 âˆ’ max Cğ‘— âˆˆK {ğ‘…(Cğ‘— , Cğ‘– )}) + 1 2
( 1 âˆ’ âˆ‘ Cğ‘—âˆ©Cğ‘–â‰ âˆ… ğ‘ƒ (Cğ‘— , Cğ‘– ) |Cğ‘— âˆ© Cğ‘– â‰  âˆ…| ) ] ,
where ğ‘…(Cğ‘— , Cğ‘– ) is the recall, ğ‘ƒ (Cğ‘— , Cğ‘– ) is the precision, and |ğ‘† (Cğ‘– ) | is the number of connected components in the subgraph induced by the members of Cğ‘– . The Deception Score yields values ranging from 0 to 1 and quantifies the hiddenness of the target community. Specifically, it measures several desiderata: reachability preservation, community spread, and community hiding. Higher values of this metric correspond with better deception. 6.4 results and discussion The experiments were conducted on the Kaggle platform,6 which provides an Intel Xeon CPU at 2.2 GHz (4 cores) and 18 GB RAM. This section is divided into two paragraphs to present the results of the two distinct tasks: node deception and community deception. Node Deception Task. In this study, we evaluate our DRL-Agentâ€™s performance against the baseline methods discussed in Section 6.2. We investigate various parameter settings, including different values for the similarity constraint ğœ (0.3, 0.5, 0.8) and the budget ğ›½ ( 12 ğœ‡, 1ğœ‡, 2ğœ‡, where ğœ‡ = | E | |V | ). We evaluate all possible combinations of these parameters. For each parameter combination, dataset, and community detection algorithm, we conducted a total of 100 experiments. In each iteration, we randomly select a node from a different community than the previous one for concealment. The reported results are based on the average outcomes across all runs. Here, we emphasize two primary findings. Firstly, our approach consistently surpasses baseline techniques when trained on the same community detection algorithm employed for the node deception task (symmetric setup). In Fig. 2, we present the Success Rate and NMI score for our DRL-Agent trained and tested on the modularity-based Greedy algorithm. A crucial observation is that our method strikes the best balance between the Success Rate and the NMI score. On the one hand, it achieves a higher success rate in hiding the selected target node than competing methods (reaching up to 80% with an improvement of approximately 15% over the best-performing baseline). On the other hand, our approach pays a limited price for this success (i.e., the modified graph remains relatively similar to the original one), as evidenced by the NMI score compared to other methods. In fact, for the words and vote datasets, the NMI score achieved by our DRL-Agent is similar to that of the baselines. In the case of the kar dataset, our methodâ€™s NMI score is slightly lower than that of, for example, Roam. However, while our method accomplishes the node deception task around 50% of the time, Roam always fails. The second key finding concerns the ability of our DRL-Agent to transfer to a different community detection algorithm (asymmetric setup). Specifically, we evaluate the performance of our method, which was trained on the modularity-based Greedy algorithm, in
6https://www.kaggle.com/
the context of a node deception task that utilizes a different community detection algorithm, namely the Louvain algorithm. As illustrated in Fig. 3, both the baselines and our DRL-Agent achieve even higher success rates in this asymmetric setting, with our method maintaining its superiority. Naturally, this outcome has a more substantial impact on the NMI score. However, intriguingly, the disparity between our methodâ€™s NMI and other approaches becomes even less pronounced than in the previous symmetric setup. Similar conclusions can be drawn for the other community detection algorithms considered and using different combinations of values for the key parameters ğœ and ğ›½ . The complete results for the node deception task are outlined in Appendix C.1. Community Deception Task.We evaluate our method against the baselines outlined in Section 6.3, using the same datasets, detection algorithms, and ğœ constraint values as the node deception task, with the only difference being the variation of ğ›½ (1, 3, 5) due to its distinct interpretation. For smaller to medium-sized datasets, the number of rewirings is fixed based on [8]. Conversely, for larger datasets, we define ğ›½ as a ratio of the community size to hide (e.g., ğ›½ = 0.1|Cğ‘– |). As with the node deception task, we examine two distinct scenarios: symmetric and asymmetric. The former involves our DRL-Agent trained on the same modularity-based community detection algorithm as used during deception, i.e., the Greedy algorithm. The latter, instead, assesses the agentâ€™s capability to adapt to a different community detection algorithm (Louvain) during deception, despite being still trained on the Greedy algorithm (transferability). In Fig. 4 and Fig. 5, we report the Deception Score (H ) and NMI score for our DRL-Agent in the symmetric and asymmetric setup, respectively. Much like our findings in the node deception task, our approach finds the optimal trade-off between these two quality metrics. This observation holds even more significance for the larger dataset (vote), where our agent not only achieves the highest Deception Score but also the best NMI score. Moreover, our DRL-Agent demonstrates the ability to transfer its performance to a community detection algorithm that differs from the one it was trained on. In summary, across various algorithms and datasets, a common trend emerges: as the ğœ similarity constraint increases, the performance of the DRL-Agent on the community deception task typically decreases. This phenomenon may arise because the agent achieves the node deception objective with fewer rewirings, resulting in
fewer actions targeting nodes with high centrality, as they are typically among the first analyzed by the algorithm. The full results of the community deception task can be found in Appendix C.2. 6.5 parameter sensitivity The effectiveness of ourDRL-Agent relies on two critical parameters: (ğ‘–) the similarity threshold (ğœ ) used to determine whether the node deception goal has been achieved or not, and (ğ‘–ğ‘–) the budget (ğ›½) to limit the effort â€“ i.e., graph modifications â€“ performed to achieve the goal. In this section, we analyze their impact. Specifically, in Table 2 and Table 3, we explore how the SR and NMI metrics for the node deception task are influenced by varying the values of ğœ and ğ›½ , while keeping the detection algorithm ğ‘“ (Â·) and dataset fixed. These results reinforce the previously mentioned findings: our method consistently achieves a superior balance between SR and NMI. Indeed, for instance, Roam has a milder impact on the graph structure, but it frequently fails to achieve the node deception goal. On the other hand, our DRL-Agent has the best success rate without overly altering the original graph. 7 ethical implications As highlighted in the motivation for this work, community membership hiding algorithms can serve as valuable tools for safeguarding the privacy of social network users. Furthermore, these methods can be used to protect individuals at risk, including journalists or opposition activists, in regions governed by authoritarian regimes. Additionally, these techniques can combat online criminal activities by modifying network connections to infiltrate espionage agents or disrupt communications among malicious users. However, node-hiding techniques can also be exploited to pursue harmful goals. For instance, malicious individuals can strategically employ these methods to evade network analysis tools, often used by law enforcement agencies for public safety, enabling them to mask their illicit or criminal activities on the network. 8 conclusion and futurework This paper tackled the challenge of community membership hiding, which entails strategically modifying the structural characteristics of a network graph to prevent specific nodes from being detected by a community detection algorithm. To address this problem, we formulated it as a constrained counterfactual graph objective and employed deep reinforcement learning for its solution. We conducted extensive experiments to validate our methodâ€™s effectiveness in two distinct tasks: node and community deception. Results demonstrated that our approach strikes the best balance between achieving the deception goal and the required cost of graph modifications compared to existing baselines in both tasks.